#include "stdafx.h"
#include "UIManager.h"
#include "PearlGui.h"

CUIManager::CUIManager()
{
	s_bKeyPressed = false;
	s_bKeyPress = false;
	IgnoreMouseProc = false;
	localInput = new CLocalInput();
	uiBase = new CN3UIBase();
	m_FocusedUI = NULL;
	uiCollectionRace = NULL;
	uiCastleSiegeWarTimer = NULL;
	uiMsgBox = NULL;
	uiDropList = NULL;
	uiDropListGroup = NULL;
	m_pUITooltipDlg = NULL;
	uiTempItemList = NULL;
	uiPowerUpStore = NULL;
	uiDropResult = NULL;
	uiSupport = NULL;
	uiTopLeft = NULL;
	uiMerchantList = NULL;
	uiSearchMonster = NULL;
	uiLottery = NULL;
	uiAccountRegister = NULL;
	uiTagChange = NULL;
	uiQuestRewards = NULL;
	uiMerchantWind = NULL;
	uiNoticeWind = NULL;
}

CUIManager::~CUIManager()
{
	s_bKeyPressed = false;
	s_bKeyPress = false;
	IgnoreMouseProc = false;
	localInput = NULL;
	uiBase->Release();
	m_FocusedUI = NULL;
	uiCollectionRace = NULL;
	uiCastleSiegeWarTimer = NULL;
	uiMsgBox = NULL;
	uiDropList = NULL;
	uiDropListGroup = NULL;
	m_pUITooltipDlg = NULL;
	uiTempItemList = NULL;
	uiPowerUpStore = NULL;
	uiDropResult = NULL;
	uiSupport = NULL;
	uiTopLeft = NULL;
	uiMerchantList = NULL;
	uiSearchMonster = NULL;
	uiLottery = NULL;
	uiAccountRegister = NULL;
	uiTagChange = NULL;
	uiQuestRewards = NULL;
	uiMerchantWind = NULL;
	uiNoticeWind = NULL;
	Release();
}

void CUIManager::Init(LPDIRECT3DDEVICE9 lDevice)
{
	uiBase->s_lpD3DDev = lDevice;
	char buff[20];
	sprintf_s(buff, "ACS[%08x]", GetCurrentProcessId()); //sonradan cagirilan uifler geldikten sonra title degistiren yer
	localInput->Init(GetModuleHandle(NULL), FindWindow(NULL, buff), FALSE);
	InitUifHookVtables();
	OpenItemInfo();
}

void CUIManager::AddChild(CN3UIBase* pChild, bool focused)
{
	//SetChildFonts(pChild, xorstr("Verdana"), 2, FALSE, FALSE);
	m_Children.push_front(pChild);

	if (focused)
		SetFocusedUI(pChild);
}

void CUIManager::RemoveChild(CN3UIBase* pChild)
{
	if (NULL == pChild) return;
	m_DestroyQueue.push_front(pChild);
}

void CUIManager::SetChildFonts(CN3UIBase* pChild, std::string fontName, int minusFontSize, bool bold, bool italic)
{
	if (pChild->UIType() == UI_TYPE_STRING)
	{
		CN3UIString* strChild = (CN3UIString*)pChild;
		strChild->SetFont(fontName, strChild->GetFontHeight() - minusFontSize, bold, italic);
	}
	else if (pChild->UIType() == UI_TYPE_LIST)
	{
		CN3UIList* listChild = (CN3UIList*)pChild;
		listChild->SetFont(fontName, listChild->FontHeight() - minusFontSize, bold, italic);
	}

	UIList myChildren = pChild->GetChildren();
	for (UIListItor itor = myChildren.begin(); myChildren.end() != itor; ++itor)
	{
		CN3UIBase* myChild = (*itor);
		SetChildFonts(myChild, fontName, minusFontSize, bold, italic);
	}
}

void CUIManager::SetChildFontsEx(CN3UIBase* pChild, std::string fontName, int fontSize, bool bold, bool italic)
{
	if (pChild->UIType() == UI_TYPE_STRING)
	{
		CN3UIString* strChild = (CN3UIString*)pChild;
		strChild->SetFont(fontName, fontSize, bold, italic);
	}
	else if (pChild->UIType() == UI_TYPE_LIST)
	{
		CN3UIList* listChild = (CN3UIList*)pChild;
		listChild->SetFont(fontName, fontSize, bold, italic);
	}

	UIList myChildren = pChild->GetChildren();
	for (UIListItor itor = myChildren.begin(); myChildren.end() != itor; ++itor)
	{
		CN3UIBase* myChild = (*itor);
		SetChildFontsEx(myChild, fontName, fontSize, bold, italic);
	}
}

bool isCursorInOurUI = false, m_bDoneSomething = false;
void CUIManager::Tick()
{
	localInput->Tick();
	POINT currentCursorPos = localInput->MouseGetPos();
	int mouseFlag = localInput->MouseGetFlag();
	IsCursorInOurUIs(currentCursorPos);
	ProcessUIKeyInput();

	DWORD dwRet = MouseProc(mouseFlag, currentCursorPos, localInput->MouseGetPosOld());
	m_bDoneSomething = false;
	if (dwRet != UI_MOUSEPROC_NONE)
		m_bDoneSomething = true;

	TickDestroyQueue();
	TickFocusedUI();

	for (UIListItor itor = m_Children.begin(); m_Children.end() != itor; ++itor)
	{
		CN3UIBase * pChild = (*itor);
		if (!pChild->IsCheckTick() && !pChild->IsVisible())
			continue;

		pChild->Tick();
	}

	if (m_pUITooltipDlg != NULL && m_pUITooltipDlg->IsVisible())
		m_pUITooltipDlg->Tick();
}

HWND gameWindow = NULL;

uint32_t CUIManager::MouseProc(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld)
{
	if (gameWindow == NULL) {
		D3DDEVICE_CREATION_PARAMETERS cparams;
		RECT rect;
		uiBase->s_lpD3DDev->GetCreationParameters(&cparams);
		gameWindow = cparams.hFocusWindow;
	}

	if (GetForegroundWindow() != gameWindow) return UI_MOUSEPROC_NONE;

	m_dwMouseFlagsCur = UI_MOUSEPROC_NONE;
	if (!m_bVisible || !m_bEnableOperation) return m_dwMouseFlagsCur;

	for (UIListItor itor = m_Children.begin(); m_Children.end() != itor; )
	{
		CN3UIBase* pChild = (*itor);

		if (pChild->m_pChildUI && pChild->m_pChildUI->IsVisible())
		{
			uint32_t dwRet = pChild->m_pChildUI->MouseProc(dwFlags, ptCur, ptOld);
			if (UI_MOUSEPROC_DONESOMETHING & dwRet)
			{
				pChild->MouseProc(0, ptCur, ptOld);
				m_dwMouseFlagsCur |= (UI_MOUSEPROC_DONESOMETHING | UI_MOUSEPROC_CHILDDONESOMETHING);

				SetFocusedUI(pChild);

				return m_dwMouseFlagsCur;
			}
			else if ((UI_MOUSE_LBCLICK & dwFlags) && (UI_MOUSEPROC_INREGION & dwRet))
			{
				pChild->MouseProc(0, ptCur, ptOld);
				m_dwMouseFlagsCur |= (UI_MOUSEPROC_DIALOGFOCUS);

				SetFocusedUI(pChild);

				return m_dwMouseFlagsCur;
			}
		}

		uint32_t dwChildRet = pChild->MouseProc(dwFlags, ptCur, ptOld);
		if (UI_MOUSEPROC_DONESOMETHING & dwChildRet)
		{
			m_dwMouseFlagsCur |= (UI_MOUSEPROC_DONESOMETHING | UI_MOUSEPROC_CHILDDONESOMETHING);

			SetFocusedUI(pChild);

			return m_dwMouseFlagsCur;
		}
		else if ((UI_MOUSE_LBCLICK & dwFlags) && (UI_MOUSEPROC_INREGION & dwChildRet))
		{
			m_dwMouseFlagsCur |= (UI_MOUSEPROC_DIALOGFOCUS);

			SetFocusedUI(pChild);

			return m_dwMouseFlagsCur;
		}
		else ++itor;

		m_dwMouseFlagsCur |= dwChildRet;
	}

	return m_dwMouseFlagsCur;
}

void CUIManager::TickDestroyQueue()
{
	bool isThisFocused = false;
	for (UIListItor ito = m_DestroyQueue.begin(); m_DestroyQueue.end() != ito; ++ito)
	{
		for (UIListItor itor = m_Children.begin(); m_Children.end() != itor;)
		{
			if ((*itor) == (*ito))
			{
				if ((*itor) == m_FocusedUI)
					isThisFocused = true;

				CN3UIBase* pChild = (*itor);
				m_Children.remove(pChild);
				delete pChild;
				break;
			}
			else ++itor;
		}
	}

	m_DestroyQueue.clear();

	if (isThisFocused)
		SetFocusedUI(GetTopUI(true));
}

void CUIManager::TickFocusedUI()
{
	if (m_FocusedUI != NULL && !m_FocusedUI->IsVisible())
		SetFocusedUI(GetTopUI(true));
}

void CUIManager::Render()
{
	if (Engine->Loading == true)
		return;

	PrepareRenderState();

	for (UIListReverseItor itor = m_Children.rbegin(); m_Children.rend() != itor; ++itor)
	{
		CN3UIBase* pChild = (*itor);
		if (!pChild->IsVisible())
			continue;

		pChild->Render();
	}

	if (m_pUITooltipDlg != NULL && m_pUITooltipDlg->IsVisible())
		m_pUITooltipDlg->Render();

	RestoreRenderState();
}

void CUIManager::IsCursorInOurUIs(POINT currentCursorPos)
{
	isCursorInOurUI = false;

	for (UIListItor itor = m_Children.begin(); m_Children.end() != itor; ++itor)
	{
		CN3UIBase* pChild = (*itor);
		if (!pChild->IsVisible())
			continue;

		if (pChild->IsIn(currentCursorPos.x, currentCursorPos.y))
		{
			isCursorInOurUI = true;
			break;
		}
	}
}

void CUIManager::SetFocusedUI(CN3UIBase* pUI)
{
	if (NULL == pUI)
	{
		m_FocusedUI = NULL;
		return;
	}

	UIListItor it = m_Children.begin(), itEnd = m_Children.end();
	it = m_Children.begin();
	bool isChild = false;
	for (; it != itEnd; it++)
	{
		if (pUI == *it)
		{
			isChild = true;
			break;
		}
	}

	if (it == itEnd || !isChild)
		return;

	it = m_Children.erase(it);
	m_Children.push_front(pUI);
	ReorderChildList();

	m_FocusedUI = GetTopUI(true);
}

void CUIManager::ReorderChildList()
{
	int iChildCount = m_Children.size();
	if (iChildCount <= 0) return;
	CN3UIBase** ppBuffer = new CN3UIBase *[iChildCount];
	int iAlwaysTopChildCount = 0;

	for (UIListItor itor = m_Children.begin(); m_Children.end() != itor; )
	{
		CN3UIBase* pChild = (*itor);
		if (pChild->GetStyle() & UISTYLE_ALWAYSTOP)
		{
			itor = m_Children.erase(itor);
			ppBuffer[iAlwaysTopChildCount++] = pChild;
		}
		else ++itor;
	}
	int i;
	for (i = iAlwaysTopChildCount - 1; i >= 0; --i)
	{
		m_Children.push_front(ppBuffer[i]);
	}
	delete[] ppBuffer;
}

CN3UIBase* CUIManager::GetTopUI(bool bVisible)
{
	if (!bVisible)
	{
		if (m_Children.empty())
			return NULL;
		return *(m_Children.begin());
	}

	for (UIListItor itor = m_Children.begin(); m_Children.end() != itor; ++itor)
	{
		CN3UIBase* pUI = (*itor);

		if (pUI->IsVisible())
			return pUI;
	}

	return NULL;
}

void CUIManager::HideAllUI()
{
	if (m_FocusedUI != NULL)
	{
		m_FocusedUI->m_bIsThisFocused = true;
		SetFocusedUI(NULL);
	}

	for (UIListItor itor = m_Children.begin(); m_Children.end() != itor; ++itor)
	{
		CN3UIBase* pChild = (*itor);
		if (!pChild->IsVisible())
			continue;

		pChild->m_bNeedToRestore = true;
		pChild->SetVisible(false);
	}
}

void CUIManager::ShowAllUI()
{
	for (UIListItor itor = m_Children.begin(); m_Children.end() != itor; ++itor)
	{
		CN3UIBase* pChild = (*itor);

		if (pChild->m_bNeedToRestore)
		{
			pChild->SetVisible(true);
			pChild->m_bNeedToRestore = false;
		}
	}

	for (UIListItor itor = m_Children.begin(); m_Children.end() != itor; ++itor)
	{
		CN3UIBase* pChild = (*itor);

		if (pChild->m_bIsThisFocused)
		{
			SetFocusedUI(pChild);
			break;
		}
	}
}

void CUIManager::PrepareRenderState()
{
	uiBase->s_lpD3DDev->GetRenderState(D3DRS_ZENABLE, &dwZEnable);
	uiBase->s_lpD3DDev->GetRenderState(D3DRS_ALPHABLENDENABLE, &dwAlphaBlend);
	uiBase->s_lpD3DDev->GetRenderState(D3DRS_SRCBLEND, &dwSrcBlend);
	uiBase->s_lpD3DDev->GetRenderState(D3DRS_DESTBLEND, &dwDestBlend);
	uiBase->s_lpD3DDev->GetRenderState(D3DRS_FOGENABLE, &dwFog);

	uiBase->s_lpD3DDev->GetSamplerState(0, D3DSAMP_MAGFILTER, &dwMagFilter);
	uiBase->s_lpD3DDev->GetSamplerState(0, D3DSAMP_MINFILTER, &dwMinFilter);
	uiBase->s_lpD3DDev->GetSamplerState(0, D3DSAMP_MIPFILTER, &dwMipFilter);

	if (D3DZB_FALSE != dwZEnable) uiBase->s_lpD3DDev->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);
	if (TRUE != dwAlphaBlend) uiBase->s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	if (D3DBLEND_SRCALPHA != dwSrcBlend) uiBase->s_lpD3DDev->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
	if (D3DBLEND_INVSRCALPHA != dwDestBlend) uiBase->s_lpD3DDev->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
	if (FALSE != dwFog) uiBase->s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE, FALSE);
	if (D3DTEXF_POINT != dwMagFilter) uiBase->s_lpD3DDev->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);
	if (D3DTEXF_POINT != dwMinFilter) uiBase->s_lpD3DDev->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_POINT);
	if (D3DTEXF_NONE != dwMipFilter) uiBase->s_lpD3DDev->SetSamplerState(0, D3DSAMP_MIPFILTER, D3DTEXF_NONE);
}

void CUIManager::RestoreRenderState()
{
	if (D3DZB_FALSE != dwZEnable) uiBase->s_lpD3DDev->SetRenderState(D3DRS_ZENABLE, dwZEnable);
	if (TRUE != dwAlphaBlend) uiBase->s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, dwAlphaBlend);
	if (D3DBLEND_SRCALPHA != dwSrcBlend) uiBase->s_lpD3DDev->SetRenderState(D3DRS_SRCBLEND, dwSrcBlend);
	if (D3DBLEND_INVSRCALPHA != dwDestBlend) uiBase->s_lpD3DDev->SetRenderState(D3DRS_DESTBLEND, dwDestBlend);
	if (FALSE != dwFog) uiBase->s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE, dwFog);
	if (D3DTEXF_POINT != dwMagFilter) uiBase->s_lpD3DDev->SetSamplerState(0, D3DSAMP_MAGFILTER, dwMagFilter);
	if (D3DTEXF_POINT != dwMinFilter) uiBase->s_lpD3DDev->SetSamplerState(0, D3DSAMP_MINFILTER, dwMinFilter);
	if (D3DTEXF_NONE != dwMipFilter) uiBase->s_lpD3DDev->SetSamplerState(0, D3DSAMP_MIPFILTER, dwMipFilter);
}

DWORD uiMgrVTable;
void CUIManager::InitUifHookVtables()
{
	CalcVtable();
	InitProcessLocalInput();
	InitMouseProc();
	InitUIHideAll();
	InitUIShowAll();
	StaticMemberInit();
}

void CUIManager::CalcVtable()
{
	m_dVTableAddr = *(DWORD*)0xF368E8; // 2228

	uiMgrVTable = m_dVTableAddr;
}

void CUIManager::StaticMemberInit()
{
	D3DDEVICE_CREATION_PARAMETERS cparams;
	CN3UIBase::s_lpD3DDev->GetCreationParameters(&cparams);
	CN3Base::s_hWndBase = cparams.hFocusWindow;

	RECT rc;
	::GetClientRect(CN3Base::s_hWndBase, &rc);
	RECT rcTmp = rc; rcTmp.left = (rc.right - rc.left) / 2; rcTmp.bottom = rcTmp.top + 30;
	CN3UIEdit::CreateEditWindow(s_hWndBase, rcTmp);
	localInput->CreateMouseWheelWindow(s_hWndBase, rcTmp);
}

void CUIManager::ProcessUIKeyInput()
{
	s_bKeyPressed = false;

	if (m_FocusedUI != NULL && m_FocusedUI && m_FocusedUI->IsVisible())
	{
		for (int i = 0; i < NUMDIKEYS; i++)
		{
			if (localInput->IsKeyPress(i))
			{
				if (m_FocusedUI->m_pChildUI && m_FocusedUI->m_pChildUI->IsVisible())
					s_bKeyPress |= m_FocusedUI->m_pChildUI->OnKeyPress(i);
				else s_bKeyPress |= m_FocusedUI->OnKeyPress(i);
			}

			if (localInput->IsKeyPressed(i))
			{
				if (m_FocusedUI->m_pChildUI && m_FocusedUI->m_pChildUI->IsVisible())
					s_bKeyPressed |= m_FocusedUI->m_pChildUI->OnKeyPressed(i);
				else s_bKeyPressed |= m_FocusedUI->OnKeyPressed(i);
			}
		}
	}

	if (s_bKeyPress)
	{
		for (int i = 0; i < NUMDIKEYS; i++)
		{
			if (localInput->IsKeyPressed(i))
			{
				if (!s_bKeyPressed) s_bKeyPress = false;
				break;
			}
		}
	}
}

RECT CUIManager::GetScreenRect()
{
	D3DDEVICE_CREATION_PARAMETERS cparams;
	RECT rect;
	CN3UIBase::s_lpD3DDev->GetCreationParameters(&cparams);
	GetWindowRect(cparams.hFocusWindow, &rect);

	IDirect3DSwapChain9* swapChain;

	CN3UIBase::s_lpD3DDev->GetSwapChain(0, &swapChain);
	D3DPRESENT_PARAMETERS params;
	swapChain->GetPresentParameters(&params);

	if (params.Windowed) rect.bottom -= 40;
	else rect.bottom += 120;

	return rect;
}

POINT CUIManager::GetScreenCenter(CN3UIBase* ui)
{
	D3DDEVICE_CREATION_PARAMETERS cparams;
	RECT rect;
	CN3UIBase::s_lpD3DDev->GetCreationParameters(&cparams);
	GetWindowRect(cparams.hFocusWindow, &rect);

	POINT ret;
	ret.x = (rect.right / 2) - (ui->GetWidth() / 2);
	ret.y = (rect.bottom / 2) - (ui->GetHeight() / 2);

	return ret;
}

const	DWORD	KO_PROCESS_LOCAL_INPUT_CALL_ADDR = 0x005541E5; // 2228
const	DWORD	KO_PROCESS_LOCAL_INPUT_FUNC = 0x005503B0; // 2228

void __stdcall ProcessLocalInput_Hook(uint32_t dwMouseFlags)
{
	DWORD thisPtr;
	__asm
	{
		MOV thisPtr, ECX
	}

	CN3UIEdit* focusedEdit = CN3UIEdit::GetFocusedEdit();
	if (focusedEdit != NULL)
	{
		if (!m_bDoneSomething)
			focusedEdit->KillFocus();
		return;
	}

	if (dwMouseFlags != 0x0 && m_bDoneSomething)
		dwMouseFlags = 0x0;

	__asm
	{
		MOV ECX, thisPtr
		PUSH dwMouseFlags
		MOV EAX, KO_PROCESS_LOCAL_INPUT_FUNC
		CALL EAX
	}
}

void CUIManager::InitProcessLocalInput()
{
	Engine->InitCallHook(KO_PROCESS_LOCAL_INPUT_CALL_ADDR, (DWORD)ProcessLocalInput_Hook);
}

const POINT CUIManager::MouseGetPos(const POINT & ptCur)
{
	POINT cur;
	if (isCursorInOurUI)
		cur.x = cur.y = 0;
	else 
		cur = ptCur;

	return cur;
}

void __stdcall MouseProc_Hook(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld)
{
	if ((dwFlags != 0x0 && isCursorInOurUI) || Engine->m_UiMgr->uiMsgBox != NULL)
		dwFlags = 0x0;

	if (uiMgrVTable == 0)
	{
		DWORD thisvTable;
		__asm
		{
			MOV thisvTable, ECX

			MOV ECX, thisvTable
			PUSH ptOld
			PUSH ptCur
			PUSH dwFlags
			CALL KO_IU_MGR_MOUSE_PROC_FUNC
		}

		return;
	}

	__asm
	{
		MOV ECX, uiMgrVTable
		PUSH ptOld
		PUSH ptCur
		PUSH dwFlags
		CALL KO_IU_MGR_MOUSE_PROC_FUNC
	}
}

void CUIManager::SendMouseProc(uint32 dwFlags, const POINT& ptCur, const POINT& ptOld)
{
	MouseProc_Hook(dwFlags, ptCur, ptOld);
}

void CUIManager::InitMouseProc()
{
	*(DWORD*)KO_IU_MGR_MOUSE_PROC_PTR = (DWORD)MouseProc_Hook;
}

void __stdcall UIHideAll_Hook()
{
	DWORD thisPtr;
	__asm
	{
		MOV thisPtr, ECX
	}

	Engine->m_UiMgr->HideAllUI();

	__asm
	{
		MOV ECX, thisPtr
		MOV EAX, KO_UI_HIDE_ALL_FUNC
		CALL EAX
	}
}

void CUIManager::InitUIHideAll()
{
	Engine->InitCallHook(KO_UI_HIDE_ALL_CALL_ADDR, (DWORD)UIHideAll_Hook);
}

void __stdcall UIShowAll_Hook()
{
	DWORD thisPtr;
	__asm
	{
		MOV thisPtr, ECX
	}

	Engine->m_UiMgr->ShowAllUI();

	__asm
	{
		MOV ECX, thisPtr
		MOV EAX, KO_UI_SHOW_ALL_FUNC
		CALL EAX
	}
}

void CUIManager::InitUIShowAll()
{
	Engine->InitCallHook(KO_UI_SHOW_ALL_CALL_ADDR, (DWORD)UIShowAll_Hook);
}

void CUIManager::ShowMessageBox(string title, string text, MsgBoxTypes type, ParentTypes parent)
{
	if (uiMsgBox == NULL) {
		Engine->m_UiMgr->uiMsgBox->OpenMessageBox(type, parent);
	} else uiMsgBox->Update(type, parent);
	
	uiMsgBox->SetTitle(title);
	uiMsgBox->SetMessage(text);
	uiMsgBox->SetVisible(true);
	SetFocusedUI(uiMsgBox);
}

void CUIManager::ShowDropList(Packet & pkt)
{
	uint16 mob;

	uint8 subcode;
	pkt >> subcode;

	if (subcode == 1) 
	{
		vector<DropItem> drops;

		pkt >> mob;

		for (int i = 0; i < 6; i++)
		{
			uint32 Item;
			uint16 Per;

			pkt >> Item >> Per;
			drops.push_back(DropItem(Item, Per));
		}

		uint8 iasMonster;
		pkt >> iasMonster;

		if (iasMonster != 0 && iasMonster != 1) iasMonster = 0;

		if (uiDropList == NULL)
		{
			Engine->m_UiMgr->uiDropList->OpenDropList();
		}

		uiDropList->Update(mob, iasMonster, drops);
		uiDropList->Open();
	}
	else if (subcode == 2)
	{
		map<uint8_t, uint32_t> items;
		uint8 size;
		pkt >> size;

		for (int i = 0; i < size; i++)
		{
			uint32 item;
			pkt >> item;
			items.insert(make_pair(i, item));
		}

		if (uiDropListGroup == NULL)
		{
			Engine->m_UiMgr->uiDropListGroup->OpenDropListGroup();
		}

		uiDropListGroup->Update(items);
		uiDropListGroup->Open();
	}
}

void CUIManager::ShowDropResult()
{
	if (uiDropResult == NULL)
	{
		Engine->m_UiMgr->uiDropResult->OpenDropResult();
	}
	Engine->m_UiMgr->uiDropResult->Open();
}

void CUIManager::ShowMerchantList(Packet & pkt)
{
	if (Engine->m_PlayerBase == NULL)
		return;

	if (uiMerchantList == NULL)
	{
		Engine->m_UiMgr->uiMerchantList->OpenMerchantList();
	}

	vector<MerchantData> merchantList;

	uint32 merchantCount;
	pkt >> merchantCount;
	for (int i = 0; i < merchantCount; i++)
	{
		MerchantData data;
		uint32 merchantID;
		uint16 socket;
		string seller;
		uint32 itemID, price;
		uint16 count;
		uint8 isKC;
		uint8 type;
		float x, y, z;
		pkt >> socket >> merchantID >> seller >> type >> itemID >> count >> price >> isKC >> x >> y >> z;
		data.type = type;
		data.socketID = socket;
		data.merchantID = merchantID;
		data.seller = seller;
		data.nItemID = itemID;
		data.price = price;
		data.count = count;
		data.isKC = isKC == 1 ? true : false;
		data.x = x;
		data.y = y;
		data.z = z;
		data.tbl = nullptr;
		merchantList.push_back(data);
	}
	uiMerchantList->merchantList = merchantList;
	uiMerchantList->SetItem(1);
	uiMerchantList->Open();
}

void CUIManager::OpenMonsterSearch()
{
	if (Engine->m_UiMgr->uiSearchMonster == NULL)
	{
		Engine->m_UiMgr->uiSearchMonster->OpenSearchMonster();
	}	
	Engine->m_UiMgr->uiSearchMonster->Open();
}

void CUIManager::OpenItemInfo()
{
	std::string name = Engine->dcpUIF(xorstr("ui\\info.Msoft"));
	m_pUITooltipDlg = new CUIImageTooltipDlg();
	m_pUITooltipDlg->Init(this);
	m_pUITooltipDlg->LoadFromFile(Engine->m_BasePath + name.c_str(), N3FORMAT_VER_1068);
	AddChild(m_pUITooltipDlg);
	remove(name.c_str());
	m_pUITooltipDlg->SetVisible(false);
	SetChildFontsEx(m_pUITooltipDlg, xorstr("Verdana"), 10, FALSE, FALSE); 	
}

void CUIManager::OpenMerchantNotice()
{
	if (Engine->m_UiMgr->uiMerchantWind == NULL)
	{
		std::string name = Engine->dcpUIF(xorstr("ui\\NoticeChat.Msoft"));
		Engine->m_UiMgr->uiMerchantWind = new CUIMerchantMsgWnd();
		Engine->m_UiMgr->uiMerchantWind->Init(Engine->m_UiMgr);
		Engine->m_UiMgr->uiMerchantWind->LoadFromFile(Engine->m_BasePath + name.c_str(), N3FORMAT_VER_1068);
		Engine->m_UiMgr->AddChild(Engine->m_UiMgr->uiMerchantWind);
		Engine->m_UiMgr->uiMerchantWind->SetVisible(false);
		if (Engine->m_UiMgr->uiMerchantWind->m_ptitle) Engine->m_UiMgr->uiMerchantWind->m_ptitle->SetString("Merchant Notices");
		remove(name.c_str());
	}

	if (Engine->m_UiMgr->uiNoticeWind == NULL)
	{
		std::string name = Engine->dcpUIF(xorstr("ui\\NoticeChat.Msoft"));
		Engine->m_UiMgr->uiNoticeWind = new CUIMoticeMsgWnd();
		Engine->m_UiMgr->uiNoticeWind->Init(Engine->m_UiMgr);
		Engine->m_UiMgr->uiNoticeWind->LoadFromFile(Engine->m_BasePath + name.c_str(), N3FORMAT_VER_1068);
		Engine->m_UiMgr->AddChild(Engine->m_UiMgr->uiNoticeWind);
		Engine->m_UiMgr->uiNoticeWind->SetVisible(false);
		if (Engine->m_UiMgr->uiNoticeWind->m_ptitle) Engine->m_UiMgr->uiNoticeWind->m_ptitle->SetString("Recent Notices");
		remove(name.c_str());
	}
}